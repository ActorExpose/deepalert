package repository

import (
	"time"

	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/aws/awserr"
	"github.com/aws/aws-sdk-go/aws/session"
	"github.com/guregu/dynamo"
	"github.com/m-mizutani/deepalert/internal/adaptor"
	"github.com/m-mizutani/deepalert/internal/errors"
	"github.com/m-mizutani/deepalert/internal/models"
)

/*
	DynamoDB Design

	Data models
	- Alert : Generated by a security monitoring device. It has attribute(s).
	- Attribute : Values appeared in an Alert (e.g. IP address, domain name, user name, etc.)
	- Content : A result of attribute inspection by Inspector
	- Report : All results. It consists of Alert(S), Content(S) and a result of Reviewer.


	Keys
	- AlertID : Generated by Alert.Detector, Alert.RuneName and Alert.AlertKey.
	- ReportID : Assigned to unique AlertKey and time range. Same AlertID can have multiple
				ReportID if timestamps of alert are distant from each other.
	- AttrHash: Hashed value of an attribute, generated by all fields of Attribute.

	Primary/secondary key design (in "pk", "sk" field and stored data)
	- alertmap/{AlertID}, fixedkey -> ReportID
	- alert/{ReportID}, cache/{random} -> Alert(s)
	- content/{ReportID}, {AttrHash}/{Random} -> Content(S)
	- attribute/{ReportID}, {AttrHash} -> Attribute (for caching)
*/

type DynamoDBRepositry struct {
	tableName  string
	region     string
	table      dynamo.Table
	timeToLive time.Duration
}

// NewDynamoDB is constructor of DynamoDBRepositry
func NewDynamoDB(region, tableName string) (adaptor.Repository, error) {
	ssn, err := session.NewSession(&aws.Config{Region: aws.String(region)})
	if err != nil {
		return nil, errors.Wrap(err, "Failed session.NewSession for DynamoDB").With("region", region)
	}
	db := dynamo.New(ssn)
	x := &DynamoDBRepositry{
		tableName:  tableName,
		region:     region,
		table:      db.Table(tableName),
		timeToLive: time.Hour * 3,
	}

	return x, nil
}

func (x *DynamoDBRepositry) PutAlertEntry(entry *models.AlertEntry, ts time.Time) error {
	cond := "(attribute_not_exists(pk) AND attribute_not_exists(sk)) OR expires_at < ?"
	if err := x.table.Put(entry).If(cond, ts.UTC().Unix()).Run(); err != nil {
		return err
	}

	return nil
}

func (x *DynamoDBRepositry) GetAlertEntry(pk, sk string) (*models.AlertEntry, error) {
	var output models.AlertEntry
	if err := x.table.Get("pk", pk).Range("sk", dynamo.Equal, sk).One(&output); err != nil {
		return nil, err
	}
	return &output, nil
}

func (x *DynamoDBRepositry) PutAlertCache(cache *models.AlertCache) error {
	if err := x.table.Put(cache).Run(); err != nil {
		return errors.Wrap(err, "Failed PutAlertCache").With("cache", cache)
	}

	return nil
}

func (x *DynamoDBRepositry) GetAlertCaches(pk string) ([]*models.AlertCache, error) {
	var caches []*models.AlertCache

	if err := x.table.Get("pk", pk).All(&caches); err != nil {
		return nil, errors.Wrap(err, "Failed GetAlertCaches").With("pk", pk)
	}

	return caches, nil
}

func (x *DynamoDBRepositry) PutReportSectionRecord(record *models.ReportSectionRecord) error {
	if err := x.table.Put(record).Run(); err != nil {
		return errors.Wrap(err, "Failed PutReportSectionRecord").With("record", record)
	}

	return nil
}

func (x *DynamoDBRepositry) GetReportSection(pk string) ([]*models.ReportSectionRecord, error) {
	var records []*models.ReportSectionRecord

	if err := x.table.Get("pk", pk).All(&records); err != nil {
		return nil, errors.Wrap(err, "Failed GetReportSection").With("pk", pk)
	}

	return records, nil
}

func (x *DynamoDBRepositry) PutAttributeCache(attr *models.AttributeCache, ts time.Time) error {
	if err := x.table.Put(attr).If("(attribute_not_exists(pk) AND attribute_not_exists(sk)) OR expires_at < ?", ts.UTC().Unix()).Run(); err != nil {
		return err
	}

	return nil
}

func (x *DynamoDBRepositry) GetAttributeCaches(pk string) ([]*models.AttributeCache, error) {
	var attrs []*models.AttributeCache

	if err := x.table.Get("pk", pk).All(&attrs); err != nil {
		return nil, errors.Wrapf(err, "Failed GetAttributeCaches").With("pk", pk)
	}

	return attrs, nil
}

// Error handling

func (x *DynamoDBRepositry) IsConditionalCheckErr(err error) bool {
	if ae, ok := err.(awserr.RequestFailure); ok {
		return ae.Code() == "ConditionalCheckFailedException"
	}
	return false
}
